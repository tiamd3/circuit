*中文*

## 动机
为什么要大费周章，难道就为了一个半加器，全加器？

要我说，这和拼乐高积木很像，积木这种游戏的乐趣在于我们可以用很低的成本对现实甚至超现实进行一个粗糙的模拟，
而数字电路同样使用一些“积木”，这种积木叫做逻辑门，每个逻辑门都有不同的功能（这和积木类似），而“搭建”的方式
则是连接这些逻辑门，数字电路和积木都用了一种思想：大的、复杂的东西可以一再拆分直到最小的模块。  

我使用了信号索引来抽象导线，比如我有一个非门`not 0 : 1`和一个`and 0 1`，表示非门介绍`0`（id）作为输入，
而使用`1`作为输出，而所谓导线则是：非门产生了一个新的信号`1`，而与门则将其作为输入，这就相当于一条导线。  

我提供了基本的语句：`[gate] number+ (':' + number)?`作为创建逻辑门的基本语句。  

这些对于信号，导线和逻辑门的抽象是基本的积木，我们可以使用它们来搭建一个复杂的世界。  

但是，等等，只有这些就够了吗，环顾四周，才发现这只不过是起点。我将通过积木的例子向你说明：
就和积木谁都能玩，但是不是谁都能玩得六是一个道理，很多人会喜欢玩拼图，搭积木这类益智游戏，但是大部分人却只是
拿着说明书按照步骤进行一种“低智”游戏，最多也就是进行一些简单实验，但他们很快就会受挫，很难取得成就感。 

人们很快发现这是一个自下而上的过程，可能每一步都要面临阻力。  

乐高向你说明了一个道理：大的东西可以拆分但小的东西很难进行有效组合，为了“有效”地进行组合，人们想尽各种办法，
其中经典的有：模块化，

## 必要说明
所有的需求都可以通过真值表进行描述。最理想的状态当然是可以直接通过真值表进行生成，这也是其中一种十分重要的能力；

### 形式转换（需求驱动）
简单的真值表（需求）转换 
*一个半加器：*  
0 0 => 0 0  
0 1 => 0 1  
1 0 => 0 1  
1 1 => 1 0  

模块化能力：将多个逻辑门打包，




## 使用指南
上半部分为状态打印区，下半部分为代码编辑区  
代码包括：  
构建逻辑电路  
input: 4 //创建一个具有四个输入的逻辑电路  
and 0 1 //创建一个与门使用默认输出  
xor 2 4 : 5 //创建一个异或门并指定输出  

状态打印  
table: 2 //打印真值表，监视输出2（可以监视多个输出）  

---

** 时序逻辑 = 组合逻辑 + 时间变量？**  

## 时间变量的本质：
关键：如何存储和使用过去的状态，
组合逻辑是关于输入的函数
时序逻辑是关于输入和现态的函数

## 触发器
D触发器实现了当CP = 1时，状态方程为 Qn+1 = D；当CP = 0时，状态方程 Qn+1 = Qn；又称锁存器。

## 疑问
触发器的实现与一般的逻辑部件的实现逻辑相同吗，是否需要隐藏一定的底层逻辑。


